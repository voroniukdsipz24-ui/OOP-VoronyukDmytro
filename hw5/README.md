# №19  
## Composite: дерево як єдина колекція

### Як Composite дозволяє працювати з ієрархічними структурами як з єдиною колекцією

Патерн **Composite** застосовується у випадках, коли програмі потрібно працювати  
з ієрархічною структурою об’єктів, організованою за принципом *«частина–ціле»*.  
Типовим прикладом є дерево, у якому:

- окремі елементи не містять підлеглих об’єктів;
- групи елементів можуть містити як окремі елементи, так і інші групи.

Головна ідея патерна полягає у створенні **спільного інтерфейсу для всіх компонентів структури**.  
Завдяки цьому клієнтський код:

- не перевіряє, чи працює він із поодиноким елементом чи з групою;
- викликає **однакові методи** для будь-якого вузла дерева;
- може сприймати всю ієрархію як **єдину логічну колекцію**.

Таким чином, Composite дозволяє значно спростити архітектуру системи  
та зробити код більш універсальним і розширюваним.

---

### Реальні сценарії використання Composite

**1. Графічні редактори**  
У графічних застосунках користувач працює з фігурами:

- колами, прямокутниками, лініями;
- групами фігур;
- вкладеними групами.

Composite дає змогу:

- переміщувати одразу всю групу;
- масштабувати її як один об’єкт;
- малювати всі вкладені елементи одним викликом методу.

---

**2. Файлова система**

Файлова система природно має деревоподібну структуру:

- файл — це кінцевий елемент;
- папка — контейнер, що може містити файли та інші папки.

Застосування Composite дозволяє:

- однаково виконувати операції над файлами й папками;
- спростити реалізацію копіювання, видалення, підрахунку розміру;
- уникнути складних перевірок типів у коді.

---

**3. Ієрархія елементів інтерфейсу (UI)**

У графічному інтерфейсі:

- кнопка — базовий елемент;
- панель — контейнер кнопок;
- вікно — контейнер панелей.

Composite забезпечує можливість:

- викликати `Render()` або `Draw()` для всього вікна;
- автоматично відмалювати всі вкладені елементи;
- будувати складні інтерфейси з простих компонентів.

---

### Переваги Composite

- **Уніфікований підхід**  
  Одиничні об’єкти та їх групи обробляються однаково.

- **Спрощення клієнтського коду**  
  Зменшується кількість умов, перевірок типів і спеціальних випадків.

- **Гнучкість розширення**  
  Легко додавати нові типи компонентів без зміни існуючого коду.

- **Природне представлення ієрархій**  
  Добре відповідає реальним структурним моделям.

---

### Недоліки Composite

- **Складність обмеження структури**  
  Важко контролювати, які саме елементи можуть бути вкладеними.

- **Надлишковість інтерфейсу**  
  Деякі методи можуть не мати сенсу для листків.

- **Ускладнення логіки**  
  Якщо поведінка листків і контейнерів сильно відрізняється,  
  реалізація стає складнішою.

---

# №20  
## Adapter / Facade / Proxy: коли застосовувати

### Реальні сценарії використання

#### Adapter

Adapter використовується тоді, коли **два компоненти мають несумісні інтерфейси**,  
але їх потрібно змусити працювати разом без зміни вихідного коду.

**Типові ситуації:**

- підключення сторонньої бібліотеки;
- інтеграція зі старою системою;
- перетворення форматів даних або API.

**Практична користь:**

- повторне використання готового коду;
- ізоляція змін у спеціальному класі-адаптері;
- відсутність впливу на клієнтський код.

---

#### Facade

Facade застосовується у випадках, коли система має **складну внутрішню структуру**  
з великою кількістю взаємопов’язаних класів.

**Типові ситуації:**

- медіасистеми, платіжні модулі, підсистеми авторизації;
- великі бібліотеки з десятками класів;
- необхідність надати простий API для клієнта.

**Практична користь:**

- приховування внутрішньої складності;
- зменшення залежностей у клієнтському коді;
- підвищення зрозумілості архітектури.

---

#### Proxy

Proxy потрібен тоді, коли необхідно **контролювати доступ до об’єкта**  
або додати додаткову поведінку без зміни самого об’єкта.

**Типові ситуації:**

- ледаче завантаження великих ресурсів;
- перевірка прав доступу;
- кешування результатів;
- логування викликів.

**Практична користь:**

- оптимізація продуктивності;
- безпека доступу;
- розширення функціональності без зміни основного класу.

---

### Як ці патерни вирішують ключові проблеми

- **Інтеграція систем**  
  Adapter перетворює інтерфейси та забезпечує сумісність.

- **Спрощення роботи з підсистемою**  
  Facade створює єдину зрозумілу точку входу.

- **Контроль доступу та оптимізація**  
  Proxy додає перевірки, кешування або відкладене створення.

---

### Ключова відмінність між Adapter, Facade і Proxy

- **Adapter**  
  Змінює інтерфейс для забезпечення сумісності.

- **Facade**  
  Не змінює інтерфейси, а лише спрощує взаємодію з підсистемою.

- **Proxy**  
  Повністю зберігає інтерфейс, але контролює доступ до реального об’єкта.

**Коротко:**

- Adapter → інтеграція  
- Facade → спрощення  
- Proxy → контроль

---

## Висновок

Їх грамотне використання підвищує **гнучкість архітектури, масштабованість системи  
та зручність подальшої підтримки програмного забезпечення**. Розглянуті патерни відіграють важливу роль у проєктуванні програмного забезпечення,  
оскільки дозволяють:

- природно працювати з ієрархічними структурами;
- інтегрувати несумісні компоненти;
- спрощувати складні системи;
- контролювати доступ до ресурсів.


